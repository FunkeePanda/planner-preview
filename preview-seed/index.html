<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Planner App</title>
    <style>
      :root { 
        --bg1:#6c63ff; --bg2:#7a3cf0; 
        --glass: rgba(255,255,255,0.08); 
        --glass-strong: rgba(255,255,255,0.12);
        --border-light: rgba(255,255,255,.12);
        --border-medium: rgba(255,255,255,.25);
        --text-primary: #fff;
        --text-muted: rgba(255,255,255,.8);
        --shadow-card: 0 6px 28px rgba(0,0,0,.25);
        --shadow-fab: 0 10px 28px rgba(0,0,0,.35);
        --radius-sm: 10px;
        --radius-md: 16px;
        --radius-pill: 999px;
      }
      *{box-sizing:border-box} html,body{height:100%}
      body{margin:0;font:16px system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;background:linear-gradient(160deg,var(--bg1),var(--bg2)) fixed;color:var(--text-primary)}
      header{position:sticky;top:0;backdrop-filter:saturate(140%) blur(8px);background:linear-gradient(160deg,rgba(255,255,255,.08),rgba(255,255,255,.04));border-bottom:1px solid var(--border-light)}
      .bar{height:60px;max-width:960px;margin:0 auto;display:flex;align-items:center;gap:12px;padding:0 16px}
      .title{font-weight:700;letter-spacing:.2px}
      main{max-width:720px;margin:16px auto;padding:16px;padding-bottom:calc(120px + env(safe-area-inset-bottom))}
      .card{background:var(--glass);border:1px solid var(--border-light);border-radius:var(--radius-md);padding:16px 18px;box-shadow:var(--shadow-card)}
      .muted{opacity:.8}

      .btn{
        height:44px; min-height:44px; padding:0 20px; min-width:80px;
        border-radius:var(--radius-pill); border:1px solid var(--border-medium);
        background:linear-gradient(160deg,rgba(255,255,255,.18),rgba(255,255,255,.10));
        backdrop-filter:saturate(140%) blur(8px);
        color:var(--text-primary); font-weight:600; font-size:14px;
        display:inline-flex; align-items:center; justify-content:center;
        cursor:pointer; transition:transform .1s ease;
      }
      .btn:active{ transform: translateY(1px); }
      .btn:hover{ background:linear-gradient(160deg,rgba(255,255,255,.22),rgba(255,255,255,.14)); }
      .btn:focus-visible{ outline:2px solid rgba(255,255,255,.9); outline-offset:2px; border-radius:3px; }

      .fab{
        position:fixed;
        right:max(16px, env(safe-area-inset-right) + 12px);
        bottom:max(16px, env(safe-area-inset-bottom) + 12px);
        height:54px; min-height:44px; min-width:54px; padding:0 16px;
        border-radius:var(--radius-pill); border:1px solid var(--border-medium);
        background:linear-gradient(160deg,rgba(255,255,255,.18),rgba(255,255,255,.10));
        backdrop-filter:saturate(140%) blur(8px);
        color:var(--text-primary); font-weight:600;
        box-shadow:var(--shadow-fab);
        z-index:9999;
      }
      .fab:active{ transform: translateY(1px); }
      .fab:focus-visible{ outline:2px solid rgba(255,255,255,.9); outline-offset:2px; border-radius:3px; }

      /* Enhanced Swipe-to-edit with clean single card */
      .task-swipe-container {
        position: relative;
        overflow: hidden;
        border-radius: 12px;
        /* Ensure consistent height for smooth animations */
        min-height: 60px;
        height: auto; /* Allow content to determine height */
        /* Force stacking context to control child layering */
        z-index: 1;
        isolation: isolate;
        /* No background - let task content be the only visible card */
      }
      
      .task-actions {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 160px; /* Wider to hold both edit and delete buttons */
        display: flex;
        align-items: center;
        justify-content: flex-end; /* Align buttons to the right side */
        gap: 8px; /* Space between buttons */
        padding-right: 12px; /* Space from the right edge */
        /* Always show background for consistent drawer look */
        background: linear-gradient(135deg, rgba(255, 165, 0, 0.95), rgba(255, 140, 0, 0.95));
        border-radius: 0 12px 12px 0;
        z-index: -10; /* Much lower than content */
        opacity: 1;
        /* Always show border and shadow for depth */
        border: 1px solid rgba(255,255,255,.12);
        border-left: none;
        box-shadow: -2px 0 8px rgba(255, 165, 0, 0.3);
        /* Remove any potential visual artifacts */
        outline: none;
      }
      
      .task-content {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        /* Solid opaque background to completely hide edit button */
        background: rgba(30, 35, 50, 1); /* Dark solid background matching theme */
        border: 1px solid rgba(255,255,255,.12);
        border-radius: 12px;
        transition: transform 0.25s cubic-bezier(0.2, 0.0, 0.2, 1);
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0; /* Ensure full coverage of container */
        z-index: 100; /* Much higher than actions */
        /* Prevent content from becoming transparent during swipe */
        will-change: transform;
        backface-visibility: hidden;
        margin: 0;
        /* Force stacking context to prevent transform interference */
        isolation: isolate;
      }
      
      .edit-btn, .delete-btn {
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        /* Touch target for mobile UX */
        width: 44px;
        height: 44px;
        min-width: 44px;
        min-height: 44px;
        /* Remove visual artifacts when hidden */
        outline: none;
        /* Prevent text selection on swipe */
        user-select: none;
        -webkit-user-select: none;
        /* Smooth transitions for interactions */
        transition: all 0.2s ease;
      }
      
      .delete-btn {
        background: rgba(220, 53, 69, 0.2);
        border-color: rgba(220, 53, 69, 0.3);
      }
      
      /* Button interaction styles */
      .edit-btn:hover, .delete-btn:hover {
        transform: scale(1.05);
      }
      
      .edit-btn:active, .delete-btn:active {
        transform: scale(0.95);
      }
      
      .delete-btn:hover {
        background: rgba(220, 53, 69, 0.3);
      }
      
      .edit-btn:focus-visible, .delete-btn:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.8);
        outline-offset: 2px;
      }
      
      /* Swipe states - card slides to reveal buttons underneath */
      .task-swipe-container.swiped .task-content {
        transform: translate3d(-120px, 0, 0);
      }
      
      /* Keep card content fixed while dragging to avoid swipe jitter */
      .task-swipe-container.dragging .task-content {
        transform: none !important;
      }
      
      /* Enhanced shadow when button is revealed */
      .task-swipe-container.swiped .task-actions {
        box-shadow: -2px 0 12px rgba(255, 165, 0, 0.5);
      }
      
      /* Completely hide edit button for completed tasks */
      .task-content.task--done ~ .task-actions {
        display: none; /* Completely remove from view */
      }
      
      /* Also hide edit buttons for any tasks in the completed section */
      #completed-list .task-actions,
      #today-completed .task-actions {
        display: none !important; /* Completely remove from view */
      }
      
      /* Drag and drop styling */
      .task-swipe-container {
        cursor: move;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      
      .task-swipe-container[draggable="true"]:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      
      .task-swipe-container.dragging {
        opacity: 0.9;
        transform: rotate(2deg) scale(1.02);
        z-index: 1000;
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
        border: 2px solid rgba(108, 99, 255, 0.5);
        transition: none !important; /* Disable transitions during drag */
        will-change: transform; /* Hint compositor */
        transform: translate3d(0,0,0) rotate(2deg) scale(1.02);
      }
      
      .flip-moving { will-change: transform; }
      
      @media (prefers-reduced-motion: reduce) {
        .flip-moving { transition: none !important; }
      }
      
      /* Reduce hover elevation while another card is being dragged */
      body.drag-active .task-swipe-container[draggable="true"]:hover {
        transform: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      
      .task-swipe-container.drag-over {
        transform: translateY(-4px);
        box-shadow: 0 6px 20px rgba(108, 99, 255, 0.3);
        border: 2px dashed rgba(108, 99, 255, 0.5);
      }
      
      .drag-placeholder {
        height: 60px;
        background: rgba(108, 99, 255, 0.1);
        border: 2px dashed rgba(108, 99, 255, 0.3);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(108, 99, 255, 0.7);
        font-size: 14px;
        margin: 5px 0;
        transition: all 0.2s ease;
      }
      
      /* Removed problematic snap-back animation that caused overflow */
      
      /* Optimized mobile experience */
      @media (max-width: 480px) {
        .task-content {
          gap: 8px;
          padding: 10px;
        }
        
        .task-actions {
          width: 130px; /* Extended background for both buttons */
          padding-right: 10px;
          gap: 6px;
        }
        
        .edit-btn, .delete-btn {
          width: 40px;
          height: 40px;
          min-width: 40px;
          min-height: 40px;
          font-size: 16px;
        }
        
        .task-swipe-container.swiped .task-content {
          transform: translate3d(-100px, 0, 0);
        }
      }

      .modal-backdrop{
        position:fixed; top:0; left:0; right:0; bottom:0;
        background:rgba(0,0,0,.6); backdrop-filter:blur(4px);
        display:flex; align-items:center; justify-content:center;
        z-index:10000;
      }
      .modal-backdrop[hidden] { display: none !important; pointer-events: none !important; }
      .modal{
        background:var(--glass-strong); border:1px solid var(--border-light);
        border-radius:var(--radius-md); padding:24px; min-width:320px; max-width:90vw;
        box-shadow:0 20px 60px rgba(0,0,0,.4);
      }
      .modal h3{ margin:0 0 16px 0; font-size:18px; }
      .modal input, .modal textarea{
        width:100%; padding:12px; margin-bottom:12px;
        border:1px solid var(--border-light); border-radius:var(--radius-sm);
        background:rgba(255,255,255,.08); color:var(--text-primary);
        font:inherit;
      }
      .modal input::placeholder, .modal textarea::placeholder{ color:var(--text-muted); }
      .modal-actions{ display:flex; gap:12px; justify-content:flex-end; margin-top:20px; }

      .tab-bar{
        position:fixed; bottom:0; 
        left:max(0px, env(safe-area-inset-left)); 
        right:max(0px, env(safe-area-inset-right));
        padding:max(8px, env(safe-area-inset-bottom) + 8px) 16px 8px;
        background:linear-gradient(160deg,rgba(255,255,255,.12),rgba(255,255,255,.08));
        backdrop-filter:saturate(140%) blur(8px);
        border-top:1px solid var(--border-light);
        display:flex; gap:4px; justify-content:center;
        z-index:9998;
      }
      .tab-btn{
        flex:1; max-width:120px; height:48px; min-height:44px; min-width:44px; padding:8px;
        border:none; background:transparent; color:var(--text-muted);
        border-radius:var(--radius-sm); font-size:12px; font-weight:500;
        display:flex; flex-direction:column; align-items:center; justify-content:center;
        cursor:pointer; transition:all .2s ease;
      }
      .tab-btn[aria-selected="true"]{
        color:var(--text-primary);
        background:rgba(255,255,255,.1);
      }
      .tab-btn:active{ transform:scale(.95); }
      .tab-btn:focus-visible{ outline:2px solid rgba(255,255,255,.9); outline-offset:2px; border-radius:3px; }

      .day-grid{
        display:grid; grid-template-columns:repeat(7,1fr); gap:8px; margin-top:12px;
      }
      .day-box{
        aspect-ratio:1; background:rgba(255,255,255,.06);
        border:1px solid var(--border-light); border-radius:8px;
        display:flex; align-items:center; justify-content:center;
        font-size:12px; font-weight:600;
      }
      .settings-row{
        display:flex; justify-content:space-between; align-items:center;
        padding:12px 0; border-bottom:1px solid rgba(255,255,255,.08);
      }
      .settings-row:last-child{ border-bottom:none; }

      .shake{
        animation: shake 0.3s ease-in-out;
      }
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
      }

      .toast{
        position:fixed; left:50%; bottom:calc(80px + env(safe-area-inset-bottom));
        transform:translateX(-50%); padding:12px 20px;
        background:rgba(0,0,0,.8); color:var(--text-primary);
        border-radius:var(--radius-pill); font-size:14px; font-weight:500;
        z-index:10001; opacity:0; transition:opacity .3s ease;
      }
      .toast.show{ opacity:1; }

      .task-ticking{
        animation: subtle-tick 2s ease-in-out infinite;
      }
      @keyframes subtle-tick {
        0%, 100% { box-shadow: 0 6px 28px rgba(0,0,0,.25); }
        50% { box-shadow: 0 6px 28px rgba(108,99,255,.15), 0 0 0 1px rgba(108,99,255,.1); }
      }

      .timer-complete-pulse{
        animation: complete-pulse 300ms ease-out;
      }
      @keyframes complete-pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); opacity: 0.8; }
        100% { transform: scale(1); }
      }

      input[type="checkbox"][data-role="toggle-done"] {
        width: 28px; height: 28px; min-width: 28px; min-height: 28px;
      }
      
      .task--done{
        opacity:0.4;
      }
      .task--done .task-title{
        text-decoration:line-through;
        opacity:.65;
      }
      .task--done .btn-start{
        display:none;
      }

      .row{
        display:flex;
        align-items:center;
      }
      .between{
        justify-content:space-between;
      }
      .small{
        font-size:13px;
      }
      .link-btn{
        background:none;
        border:none;
        color:var(--text-primary);
        text-decoration:underline;
        cursor:pointer;
        font:inherit;
        padding:0;
      }
      .link-btn:hover{
        opacity:.8;
      }

      .sr-only{
        position:absolute;
        width:1px;
        height:1px;
        padding:0;
        margin:-1px;
        overflow:hidden;
        clip:rect(0,0,0,0);
        white-space:nowrap;
        border:0;
      }

      /* Allow siblings to be hit-tested while dragging; keep dragged card interactive */
      body.drag-active .task-swipe-container.dragging { pointer-events: auto; }
    </style>
  </head>
  <body>
    <header><div class="bar"><div class="title">Planner App</div></div></header>

    <main>
      <section id="tab-today">
                  <div class="card">
          <h2 style="margin:0 0 10px 0">Today â€” step 1.62-drag-visual-sync</h2>
          <div class="muted" style="margin-bottom:14px">Visual sync: hide drag clone + immediate render on drop; no snap-back.</div>

          <div id="today-list" style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:10px">
            <!-- Tasks will be rendered here by JavaScript -->
          </div>

                      <!-- Completed bucket (like React section with conditional Clear button) -->
            <section id="today-completed" aria-label="Completed" style="margin-top:16px" data-testid="completed-section">
              <header class="row between small muted" style="margin-bottom:12px">
                <span>Completed (<span id="completed-count">0</span>)</span>
                <button id="clear-completed" class="link-btn" style="display:none">Clear</button>
              </header>
              <div id="completed-list" style="display:grid;gap:10px"></div>
            </section>

            <!-- Debug footer -->
            <footer id="debug-footer" style="opacity:.6;font-size:12px;padding:8px 16px;margin-top:16px">
              build: STEP-1.62-drag-visual-sync â€” active:0 done:0
            </footer>
        </div>
      </section>

      <section id="tab-week" hidden>
        <div class="card">
          <h2 style="margin:0 0 10px 0">Week (placeholder)</h2>
          <div class="muted" style="margin-bottom:14px">Weekly view coming soon.</div>
          <div class="day-grid">
            <div class="day-box">M</div>
            <div class="day-box">T</div>
            <div class="day-box">W</div>
            <div class="day-box">T</div>
            <div class="day-box">F</div>
            <div class="day-box">S</div>
            <div class="day-box">S</div>
          </div>
        </div>
      </section>

      <section id="tab-settings" hidden>
        <div class="card">
          <h2 style="margin:0 0 16px 0">Settings</h2>
          <div class="settings-row">
            <span>Theme</span>
            <span class="muted">System</span>
          </div>
          <div class="settings-row">
            <span>Conflicts</span>
            <span class="muted">On</span>
          </div>
          <div class="settings-row">
            <span>Export</span>
            <button id="export-json-btn" class="btn">Export JSON</button>
          </div>
          <div class="settings-row">
            <span>Import</span>
            <div style="display:flex;align-items:center;gap:8px">
              <button id="import-json-btn" class="btn">Import JSON</button>
              <span class="muted" style="font-size:12px">Replaces all tasks</span>
            </div>
          </div>
          <input id="import-file" type="file" accept="application/json" style="display:none" />
        </div>
      </section>
    </main>

    <div id="modal-backdrop" class="modal-backdrop" hidden>
      <div class="modal">
        <h3>New Task</h3>
        <form id="task-form">
          <input id="task-title" type="text" placeholder="Task name" required />
          <select id="task-duration">
            <option value="">None</option>
            <option value="5">5 minutes</option>
            <option value="15">15 minutes</option>
            <option value="25">25 minutes</option>
            <option value="45">45 minutes</option>
          </select>
          <input id="task-tag" type="text" placeholder="Tag or area (optional)" />
        </form>
        <div class="modal-actions">
          <button id="modal-cancel" class="btn">Cancel</button>
          <button id="modal-save" class="btn">Save</button>
        </div>
      </div>
    </div>

    <!-- Edit Task Modal -->
    <div id="edit-modal-backdrop" class="modal-backdrop" hidden>
      <div class="modal">
        <h3>Edit Task</h3>
        <form id="edit-task-form">
          <input id="edit-task-title" type="text" placeholder="Task name" required />
          <select id="edit-task-duration">
            <option value="">None</option>
            <option value="5">5 minutes</option>
            <option value="15">15 minutes</option>
            <option value="25">25 minutes</option>
            <option value="45">45 minutes</option>
          </select>
          <input id="edit-task-tag" type="text" placeholder="Tag or area (optional)" />
        </form>
        <div class="modal-actions">
          <button id="edit-modal-cancel" class="btn">Cancel</button>
          <button id="edit-modal-save" class="btn">Save Changes</button>
        </div>
      </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-modal-backdrop" class="modal-backdrop" hidden>
      <div class="modal" onclick="event.stopPropagation()" style="max-width:400px">
        <h3 style="margin:0 0 12px 0;color:#fff">Delete this task?</h3>
        
        <p style="margin:0 0 20px 0;color:rgba(255,255,255,0.8);line-height:1.4">
          Are you sure you want to delete this task? This cannot be undone.
        </p>
        
        <div class="modal-actions">
          <button id="delete-modal-cancel" class="btn">Cancel</button>
          <button id="delete-modal-confirm" class="btn" style="background:#dc3545;border:1px solid #dc3545;color:#fff">Delete</button>
        </div>
      </div>
    </div>

    <div class="tab-bar">
      <button class="tab-btn" data-tab="today" aria-selected="true">Today</button>
      <button class="tab-btn" data-tab="week" aria-selected="false">Week</button>
      <button class="tab-btn" data-tab="settings" aria-selected="false">Settings</button>
    </div>

    <button class="fab" aria-label="Add task">+ Add task</button>

    <!-- Accessibility announcements -->
    <div id="task-announcements" class="sr-only" aria-live="polite"></div>

    <!-- build-stamp: to verify deploy -->
    <div style="position:fixed;left:8px;bottom:8px;font-size:11px;opacity:.55">
      build: STEP-1.62-drag-visual-sync
    </div>

    <script>
      // Debug flag to reduce console littering (set to true to re-enable verbose logs)
      window.__DRAG_DEBUG = false;
      // Storage helper with migration support
      const LS_KEY = 'planner.tasks.v1';
      
      function generateId() {
        // Use crypto.randomUUID if available, fallback to timestamp + random
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
          return crypto.randomUUID();
        }
        return Date.now().toString() + Math.random().toString(36).substr(2, 5);
      }

      function seedTasks() {
        const base = [
          { id: generateId(), title: 'Task A', completed: false, tag: 'Alpha', minutes: 15 },
          { id: generateId(), title: 'Task B', completed: false, tag: 'Beta', minutes: 5 },
          { id: generateId(), title: 'Task C', completed: false, tag: 'Gamma' },
          { id: generateId(), title: 'Task D', completed: false, tag: 'Delta', minutes: 25 },
          { id: generateId(), title: 'Task E', completed: false, tag: 'Epsilon' }
        ];
        localStorage.setItem(LS_KEY, JSON.stringify(base));
        return base;
      }

      function loadTasks() {
        try {
          console.log('ðŸ“‚ Loading tasks from localStorage...');
          const raw = localStorage.getItem(LS_KEY);
          if (!raw) {
            console.log('ðŸ“‚ No tasks found, seeding default tasks');
            return seedTasks();
          }
          const parsed = JSON.parse(raw);
          console.log('ðŸ“‚ Loaded tasks from storage:', parsed.length, 'tasks');
          console.log('ðŸ“‚ Task IDs loaded:', parsed.map(t => `${t.id}:${t.title}`));
          
          // Migration-friendly task normalization
          const normalized = parsed.map((t, index) => ({
            id: String(t.id || generateId()),
            title: String(t.title || 'Untitled'),
            note: t.note || '',
            minutes: typeof t.minutes === 'number' ? t.minutes : undefined,
            tag: t.tag || '',
            // Coerce any old flags (checked, done, isDone) into `completed`
            completed: !!(t.completed || t.checked || t.done || t.isDone || false),
            // Add sortOrder for drag and drop (migration)
            sortOrder: t.sortOrder !== undefined ? t.sortOrder : index * 1000,
            // Add timer if missing (migration)
            timer: t.timer || (t.minutes ? {
              totalSec: t.minutes * 60,
              remainingSec: t.minutes * 60,
              status: 'idle',
              updatedAt: Date.now()
            } : null)
          }));
          
          console.log('ðŸ“‚ Normalized tasks:', normalized.length, normalized.map(t => `${t.id}:${t.title}`));
          return normalized;
        } catch (e) {
          console.warn('Failed to parse stored tasks:', e);
          return seedTasks();
        }
      }

      function saveTasks(tasks) {
        try {
          console.log('ðŸ’¾ Saving tasks to localStorage:', tasks.length, 'tasks');
          console.log('ðŸ’¾ Task IDs being saved:', tasks.map(t => `${t.id}:${t.title}`));
          localStorage.setItem(LS_KEY, JSON.stringify(tasks));
          console.log('ðŸ’¾ Save successful');
        } catch (e) {
          console.warn('Failed to store tasks:', e);
        }
      }

      // Timer utilities
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      function tickTimer(task) {
        if (!task.timer || task.timer.status !== 'running') return task;
        const now = Date.now();
        const elapsed = Math.floor((now - task.timer.updatedAt) / 1000);
        const newRemaining = Math.max(0, task.timer.remainingSec - elapsed);
        
        return {
          ...task,
          timer: {
            ...task.timer,
            remainingSec: newRemaining,
            updatedAt: now
          }
        };
      }

      // Debounced save to avoid localStorage thrashing
      let saveTimeout;
      function debouncedSave(tasks) {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => saveTasks(tasks), 1000);
      }

      // Placeholder for future native haptics
      function tryHaptic(type) {
        console.log(`Haptic feedback: ${type}`);
      }

      // Simple tab switching
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const targetTab = btn.dataset.tab;
          
          // Haptic feedback
          tryHaptic('tab');
          
          // Hide all sections
          document.querySelectorAll('section[id^="tab-"]').forEach(section => {
            section.hidden = true;
          });
          
          // Show target section
          document.getElementById(`tab-${targetTab}`).hidden = false;
          
          // Update tab button states
          document.querySelectorAll('.tab-btn').forEach(b => {
            b.setAttribute('aria-selected', 'false');
          });
          btn.setAttribute('aria-selected', 'true');
        });
      });

      // Toast helper
      function createToast(text) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = text;
        document.body.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 10);
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => document.body.removeChild(toast), 300);
        }, 1500);
      }

      // Task creation helper with swipe-to-edit support
      function createTaskCard(task) {
        // Create swipe container
        const swipeContainer = document.createElement('div');
        swipeContainer.className = 'task-swipe-container';
        swipeContainer.dataset.taskId = task.id;
        swipeContainer.dataset.testid = `task-row-${task.id}`;
        
        // Make active tasks draggable
        if (!task.completed) {
          swipeContainer.draggable = true;
          swipeContainer.dataset.sortOrder = task.sortOrder || 0;
        }
        
        // Create task content
        const taskContent = document.createElement('div');
        taskContent.className = 'task-content';
        
        const tagLine = task.tag ? `<div class="muted" style="font-size:13px">${task.tag}</div>` : '';
        
        // Show live timer or static duration
        let timerDisplay = '';
        let buttonText = 'Start';
        let resetLink = '';
        
        if (task.timer) {
          const remaining = task.timer.remainingSec;
          timerDisplay = `<span style="font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.08)">${formatTime(remaining)}</span>`;
          
          if (task.timer.status === 'running') {
            buttonText = 'Pause';
            resetLink = '<button data-role="reset-timer" style="background:none;border:none;color:rgba(255,255,255,.6);font-size:11px;margin-left:8px;cursor:pointer">Reset</button>';
          } else if (task.timer.status === 'paused') {
            buttonText = 'Resume';
            resetLink = '<button data-role="reset-timer" style="background:none;border:none;color:rgba(255,255,255,.6);font-size:11px;margin-left:8px;cursor:pointer">Reset</button>';
          }
        } else if (task.minutes) {
          timerDisplay = `<span style="font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.08)">${task.minutes}m</span>`;
        }
        
        // Create checkbox as DOM element to ensure events work
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.dataset.role = 'toggle-done';
        checkbox.checked = task.completed;
        checkbox.setAttribute('aria-label', `Mark ${task.title} ${task.completed ? 'incomplete' : 'complete'}`);
        
        // Add direct event listener to checkbox
        checkbox.addEventListener('change', function(e) {
          console.log('ðŸ”„ Direct checkbox change event fired for task:', task.id);
          toggleComplete(task.id);
        });
        
        // Create the rest with innerHTML
        const contentDiv = document.createElement('div');
        contentDiv.innerHTML = `
          <div style="flex:1">
            <div class="task-title" style="font-weight:600">${task.title}</div>
            ${tagLine}
          </div>
          ${timerDisplay}
          <button class="btn-start" data-role="timer-control" style="margin-left:8px;padding:6px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.08);color:#fff">${buttonText}</button>
          ${resetLink}
        `;
        
        // Append checkbox and content to task content
        taskContent.appendChild(checkbox);
        while (contentDiv.firstChild) {
          taskContent.appendChild(contentDiv.firstChild);
        }
        
        // Create edit and delete actions
        const taskActions = document.createElement('div');
        taskActions.className = 'task-actions';
        
        // Create delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = 'ðŸ—‘ï¸';
        deleteBtn.setAttribute('aria-label', 'Delete task');
        deleteBtn.addEventListener('click', function() {
          deleteTask(task.id);
        });
        
        // Create edit button
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-btn';
        editBtn.innerHTML = 'âœï¸';
        editBtn.setAttribute('aria-label', 'Edit task');
        editBtn.addEventListener('click', function() {
          openEditModal(task);
        });
        
        // Append buttons (delete first, then edit - right to left order)
        taskActions.appendChild(deleteBtn);
        taskActions.appendChild(editBtn);
        
        // Add swipe gesture support
        addSwipeGesture(swipeContainer, taskContent);
        
        // Append actions first (behind), then content (on top)
        swipeContainer.appendChild(taskActions);
        swipeContainer.appendChild(taskContent);
        
        if (task.completed) {
          taskContent.classList.add('task--done');
        }
        
        // Add ticking animation if timer is running
        if (task.timer && task.timer.status === 'running') {
          taskContent.classList.add('task-ticking');
        }
        
        return swipeContainer;
      }
      
      // Custom drag and drop functionality (works on mobile and desktop)
      let draggedElement = null;
      let draggedTaskId = null;
      let dragPlaceholder = null;
      let isDragMode = false;
      let isRenderSuppressedForDrag = false; // Gate renders while dragging
      let dropUpdateScheduled = false; // rAF throttle for drop target updates
      let dragMoveScheduled = false; // rAF throttle for drag transform updates
      let dragBaseLeft = 0; // Base left at drag start
      let dragBaseTop = 0;  // Base top at drag start
      let lastPlaceholderAnchorId = null; // For hysteresis
      let lastPlaceholderAfter = null;    // true if after, false if before
      let dragLastIndex = null;           // Last placeholder index inserted
      let dragLastSwitchY = 0;            // Y position at last index switch
      let isGestureDecided = false; // Track if we've decided between drag and swipe
      let dragStartPos = { x: 0, y: 0 };
      let dragCurrentPos = { x: 0, y: 0 };
      let dragOffset = { x: 0, y: 0 };
      let dragThreshold = 10; // pixels to move before starting drag
      
      function addDragAndDropHandlers() {
        const todayList = document.getElementById('today-list');
        
        // Add custom drag handlers for both mouse and touch
        todayList.addEventListener('mousedown', handleDragMouseDown);
        todayList.addEventListener('touchstart', handleDragTouchStart, { passive: false });
        
        // Global handlers for drag move and end
        document.addEventListener('mousemove', handleDragMouseMove);
        document.addEventListener('touchmove', handleDragTouchMove, { passive: false });
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);
        document.addEventListener('touchcancel', handleDragEnd);
      }
      
      function handleDragMouseDown(e) {
        // Don't interfere with buttons, inputs, or edit actions
        if (e.target.closest('.edit-btn') || e.target.closest('.delete-btn') || 
            e.target.closest('input') || e.target.closest('button') || 
            e.target.closest('.task-actions')) {
          return;
        }
        
        const taskCard = e.target.closest('.task-swipe-container');
        if (!taskCard || !taskCard.draggable || taskCard.classList.contains('task--done')) {
          return;
        }
        
        console.log('ðŸ”¥ DevLog: Mouse down on draggable task - preparing for potential drag:', taskCard.dataset.taskId);
        
        // Only store initial position, don't set draggedElement yet
        // Let the move handler determine if this becomes a drag or swipe
        dragStartPos.x = e.clientX;
        dragStartPos.y = e.clientY;
        
        // Store reference but don't commit to drag yet
        const rect = taskCard.getBoundingClientRect();
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;
        
        // Store potential drag element but don't activate drag mode
        window._potentialDragElement = taskCard;
        window._potentialDragTaskId = taskCard.dataset.taskId;
        
        // Don't prevent default - let swipe handle it if it's horizontal
      }
      
      function handleDragTouchStart(e) {
        // Don't interfere with buttons, inputs, or edit actions
        if (e.target.closest('.edit-btn') || e.target.closest('.delete-btn') || 
            e.target.closest('input') || e.target.closest('button') || 
            e.target.closest('.task-actions')) {
          return;
        }
        
        const taskCard = e.target.closest('.task-swipe-container');
        if (!taskCard || !taskCard.draggable || taskCard.classList.contains('task--done')) {
          return;
        }
        
        console.log('ðŸ”¥ DevLog: Touch start on draggable task:', taskCard.dataset.taskId);
        
        const touch = e.touches[0];
        dragStartPos.x = touch.clientX;
        dragStartPos.y = touch.clientY;
        draggedElement = taskCard;
        draggedTaskId = taskCard.dataset.taskId;
        
        // Calculate offset from touch to element top-left
        const rect = taskCard.getBoundingClientRect();
        dragOffset.x = touch.clientX - rect.left;
        dragOffset.y = touch.clientY - rect.top;
        
        e.preventDefault();
      }
      
      function handleDragMouseMove(e) {
        // Check if we have a potential drag element
        if (!window._potentialDragElement && !draggedElement) return;
        
        dragCurrentPos.x = e.clientX;
        dragCurrentPos.y = e.clientY;
        
        // Check if we've moved enough to determine gesture intent
        const deltaX = Math.abs(dragCurrentPos.x - dragStartPos.x);
        const deltaY = Math.abs(dragCurrentPos.y - dragStartPos.y);
        const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (!isDragMode && !isGestureDecided && totalMovement > dragThreshold) {
          // Determine if this is more horizontal (swipe) or vertical (drag) movement
          const isMoreHorizontal = deltaX > deltaY * 1.5; // Favor horizontal for swipe
          
          isGestureDecided = true; // Lock in the gesture type
          
          if (isMoreHorizontal) {
            // This looks like a swipe gesture, cancel drag
            console.log('ðŸ”„ DevLog: Horizontal movement detected, letting swipe handle it');
            cancelDragForSwipe();
            return;
          } else {
            // This looks like a drag gesture, activate drag mode now
            console.log('ðŸ”„ DevLog: Vertical/mixed movement detected, starting drag');
            if (window._potentialDragElement) {
              draggedElement = window._potentialDragElement;
              draggedTaskId = window._potentialDragTaskId;
              window._potentialDragElement = null;
              window._potentialDragTaskId = null;
            }
            startDragMode();
          }
        }
        
        if (isDragMode && draggedElement) {
          updateDragPosition(e.clientX, e.clientY);
          updateDropTarget(e.clientX, e.clientY);
        }
      }
      
      function handleDragTouchMove(e) {
        if (!draggedElement) return;
        
        const touch = e.touches[0];
        dragCurrentPos.x = touch.clientX;
        dragCurrentPos.y = touch.clientY;
        
        // Check if we've moved enough to determine gesture intent
        const deltaX = Math.abs(dragCurrentPos.x - dragStartPos.x);
        const deltaY = Math.abs(dragCurrentPos.y - dragStartPos.y);
        const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (!isDragMode && !isGestureDecided && totalMovement > dragThreshold) {
          // Determine if this is more horizontal (swipe) or vertical (drag) movement
          const isMoreHorizontal = deltaX > deltaY * 1.5; // Favor horizontal for swipe
          
          isGestureDecided = true; // Lock in the gesture type
          
          if (isMoreHorizontal) {
            // This looks like a swipe gesture, cancel drag
            console.log('ðŸ”„ DevLog: Horizontal touch movement detected, canceling drag for swipe');
            cancelDragForSwipe();
            return;
          } else {
            // This looks like a drag gesture, start drag mode
            console.log('ðŸ”„ DevLog: Vertical/mixed touch movement detected, starting drag');
            startDragMode();
          }
        }
        
        if (isDragMode) {
          updateDragPosition(touch.clientX, touch.clientY);
          updateDropTarget(touch.clientX, touch.clientY);
          e.preventDefault(); // Prevent scrolling during drag
        }
      }
      
      function cancelDragForSwipe() {
        // Cancel the drag operation and let swipe take over
        console.log('ðŸ”„ DevLog: Canceling drag, allowing swipe to proceed');
        
        // Clean up drag state
        draggedElement = null;
        draggedTaskId = null;
        isDragMode = false;
        isGestureDecided = false; // Reset gesture decision
        dragStartPos = { x: 0, y: 0 };
        dragCurrentPos = { x: 0, y: 0 };
        dragOffset = { x: 0, y: 0 };
        
        // Clean up potential drag state
        window._potentialDragElement = null;
        window._potentialDragTaskId = null;
        
        // Remove any placeholder
        if (dragPlaceholder && dragPlaceholder.parentNode) {
          dragPlaceholder.remove();
          dragPlaceholder = null;
        }
      }
      
      function startDragMode() {
        if (!draggedElement) return;
        
        if (window.__DRAG_DEBUG) console.log('ðŸ”¥ DevLog: Starting drag mode for task:', draggedTaskId);
        isDragMode = true;
        isRenderSuppressedForDrag = true;
        document.body.classList.add('drag-active');
        dragLastIndex = null;
        dragLastSwitchY = 0;
        
        // Clear any swipe state on the dragged card
        try {
          draggedElement.classList.remove('swiped');
          const content = draggedElement.querySelector('.task-content');
          if (content) {
            content.style.transform = '';
          }
        } catch {}
        
        // Store original styles to restore later
        const originalStyles = {
          position: draggedElement.style.position,
          zIndex: draggedElement.style.zIndex,
          width: draggedElement.style.width,
          height: draggedElement.style.height,
          transform: draggedElement.style.transform,
          transition: draggedElement.style.transition
        };
        draggedElement._originalStyles = originalStyles;
        
        // Get current dimensions before changing position
        const rect = draggedElement.getBoundingClientRect();
        
        // Add visual feedback - keep the card visible and elevated
        draggedElement.classList.add('dragging');
        draggedElement.style.position = 'fixed';
        draggedElement.style.zIndex = '1000';
        draggedElement.style.width = rect.width + 'px';
        draggedElement.style.height = rect.height + 'px';
        draggedElement.style.transition = 'none'; // Disable transitions during drag
        draggedElement.style.pointerEvents = 'auto'; // Keep interactions enabled
        
        // Position the card at current location initially
        draggedElement.style.left = rect.left + 'px';
        draggedElement.style.top = rect.top + 'px';
        dragBaseLeft = rect.left;
        dragBaseTop = rect.top;
        
        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
        
        // Create an initial placeholder in the original position
        const placeholder = document.createElement('div');
        placeholder.className = 'drag-placeholder';
        placeholder.innerHTML = 'â¬‡ Drop here';
        placeholder.style.height = rect.height + 'px';
        placeholder.style.margin = getComputedStyle(draggedElement).margin;
        draggedElement.parentNode.insertBefore(placeholder, draggedElement);
        dragPlaceholder = placeholder;
      }
      
      function updateDragPosition(clientX, clientY) {
        if (!draggedElement || !isDragMode) return;

        const targetLeft = clientX - dragOffset.x;
        const targetTop = clientY - dragOffset.y;
        const dx = targetLeft - dragBaseLeft;
        const dy = targetTop - dragBaseTop;

        if (dragMoveScheduled) return;
        dragMoveScheduled = true;
        requestAnimationFrame(() => {
          dragMoveScheduled = false;
          // Transform-only movement for smoothness; keep fixed left/top as base
          draggedElement.style.transform = `translate(${dx}px, ${dy}px)`;
        });
      }
      
      function updateDropTarget(clientX, clientY) {
        if (!isDragMode) return;

        // Throttle updates to the next animation frame for smoothness
        if (dropUpdateScheduled) return;
        dropUpdateScheduled = true;
        requestAnimationFrame(() => {
          dropUpdateScheduled = false;

          const todayList = document.getElementById('today-list');
          if (!todayList) return;

          // Build array of all task cards (exclude dragged element) for robust indexing
          const droppables = Array.from(todayList.querySelectorAll('.task-swipe-container')).filter(el => el !== draggedElement);

          // Clamp target Y to list bounds with small padding
          const listRect = todayList.getBoundingClientRect();
          const y = Math.max(listRect.top + 2, Math.min(clientY, listRect.bottom - 2));

          // Prefer nearest card via elementFromPoint, fallback to center scan
          let overCard = null;
          const prevPE = draggedElement.style.pointerEvents;
          draggedElement.style.pointerEvents = 'none';
          const elUnder = document.elementFromPoint(clientX, clientY);
          draggedElement.style.pointerEvents = prevPE;
          if (elUnder) {
            const candidate = elUnder.closest('.task-swipe-container');
            if (candidate && todayList.contains(candidate) && candidate !== draggedElement) {
              overCard = candidate;
            }
          }

          let newIndex;
          if (overCard) {
            const i = droppables.indexOf(overCard);
            if (i === -1) {
              newIndex = droppables.length;
            } else {
              const r = overCard.getBoundingClientRect();
              const ratio = (y - r.top) / r.height;
              newIndex = i + (ratio > 0.5 ? 1 : 0);
            }
          } else {
            // Fallback: compute by centers
            newIndex = droppables.length;
            for (let i = 0; i < droppables.length; i++) {
              const r = droppables[i].getBoundingClientRect();
              const center = r.top + r.height / 2;
              if (y < center) { newIndex = i; break; }
            }
          }
          newIndex = Math.max(0, Math.min(newIndex, droppables.length));

          // Hysteresis buffer: require minimum Y travel before changing index
          const MIN_TRAVEL_PX = 6; // smaller threshold to allow smooth multi-card jumps
          if (dragLastIndex !== null && newIndex !== dragLastIndex) {
            if (Math.abs(y - dragLastSwitchY) < MIN_TRAVEL_PX) {
              newIndex = dragLastIndex; // hold position until sufficient travel
            }
          }

          // Ensure placeholder exists
          if (!dragPlaceholder) {
            dragPlaceholder = document.createElement('div');
            dragPlaceholder.className = 'drag-placeholder';
            dragPlaceholder.innerHTML = 'â¬‡ Drop here';
            dragPlaceholder.style.height = (draggedElement.getBoundingClientRect().height) + 'px';
            dragPlaceholder.style.margin = getComputedStyle(draggedElement).margin;
          }

          // Determine desired beforeNode in droppables space
          const beforeNode = (newIndex >= droppables.length) ? null : droppables[newIndex];

          // FLIP: measure first positions for siblings (excluding dragged and placeholder)
          const firstRects = new Map();
          for (const el of droppables) {
            if (el !== dragPlaceholder && el !== draggedElement) {
              firstRects.set(el, el.getBoundingClientRect());
            }
          }

          // Only move placeholder if its current position differs
          const currentNext = dragPlaceholder.nextElementSibling;
          const isAlreadyCorrect = (beforeNode === null && dragPlaceholder === todayList.lastElementChild) || (beforeNode !== null && currentNext === beforeNode);
          if (!isAlreadyCorrect) {
            if (beforeNode === null) {
              todayList.appendChild(dragPlaceholder);
            } else {
              todayList.insertBefore(dragPlaceholder, beforeNode);
            }
            dragLastIndex = newIndex;
            dragLastSwitchY = y;

            // FLIP: measure last, invert, and animate
            requestAnimationFrame(() => {
              for (const el of droppables) {
                if (el === dragPlaceholder || el === draggedElement) continue;
                const first = firstRects.get(el);
                if (!first) continue;
                const last = el.getBoundingClientRect();
                const dx = first.left - last.left;
                const dy = first.top - last.top;
                if (dx !== 0 || dy !== 0) {
                  el.classList.add('flip-moving');
                  el.style.transition = 'none';
                  el.style.transform = `translate3d(${dx}px, ${dy}px, 0)`;
                  requestAnimationFrame(() => {
                    el.style.transition = 'transform 180ms cubic-bezier(0.2, 0.0, 0.2, 1)';
                    el.style.transform = 'translate3d(0, 0, 0)';
                  });
                  const cleanup = () => {
                    el.style.transition = '';
                    el.style.transform = '';
                    el.classList.remove('flip-moving');
                    el.removeEventListener('transitionend', cleanup);
                  };
                  el.addEventListener('transitionend', cleanup);
                }
              }
            });
          }
        });
      }
      
      function handleDragEnd(e) {
        if (!draggedElement) return;
        
        if (window.__DRAG_DEBUG) console.log('ðŸ”¥ DevLog: Drag end for task:', draggedTaskId);
        
        if (isDragMode && dragPlaceholder) {
          // Calculate new position based on placeholder (consider only task cards)
          const todayList = document.getElementById('today-list');
          const droppables = Array.from(todayList.querySelectorAll('.task-swipe-container')).filter(el => el !== draggedElement);
          const nextSibling = dragPlaceholder.nextElementSibling;
          let dropIndex = nextSibling ? droppables.indexOf(nextSibling) : droppables.length;
          if (dropIndex < 0) dropIndex = droppables.length;
          
          if (window.__DRAG_DEBUG) console.log('ðŸ”¥ DevLog: Dropping at index:', dropIndex);
          
          // Re-enable renders before persisting order so UI updates immediately
          isRenderSuppressedForDrag = false;
          // Hide the fixed-position dragged element clone so new order is visible immediately
          try { if (draggedElement) draggedElement.style.visibility = 'hidden'; } catch {}
          
          // Update sort order
          updateTaskSortOrder(draggedTaskId, dropIndex);
        }
        
        // Clean up
        if (draggedElement) {
          draggedElement.classList.remove('dragging');
          
          // Restore original styles
          const originalStyles = draggedElement._originalStyles;
          if (originalStyles) {
            draggedElement.style.position = originalStyles.position;
            draggedElement.style.zIndex = originalStyles.zIndex;
            draggedElement.style.width = originalStyles.width;
            draggedElement.style.height = originalStyles.height;
            draggedElement.style.transform = originalStyles.transform;
            draggedElement.style.transition = originalStyles.transition;
            draggedElement.style.left = '';
            draggedElement.style.top = '';
            draggedElement.style.pointerEvents = '';
            delete draggedElement._originalStyles;
          } else {
            // Fallback cleanup
            draggedElement.style.position = '';
            draggedElement.style.zIndex = '';
            draggedElement.style.width = '';
            draggedElement.style.height = '';
            draggedElement.style.transform = '';
            draggedElement.style.transition = '';
            draggedElement.style.left = '';
            draggedElement.style.top = '';
            draggedElement.style.pointerEvents = '';
          }
        }
        
        if (dragPlaceholder) {
          dragPlaceholder.remove();
          dragPlaceholder = null;
        }
        
        // Reset state
        draggedElement = null;
        draggedTaskId = null;
        isDragMode = false;
        isRenderSuppressedForDrag = false;
        document.body.classList.remove('drag-active');
        isGestureDecided = false; // Reset gesture decision
        dragStartPos = { x: 0, y: 0 };
        dragCurrentPos = { x: 0, y: 0 };
        dragOffset = { x: 0, y: 0 };
        lastPlaceholderAnchorId = null;
        lastPlaceholderAfter = null;
        // Force a render pass now that drag suppression is off to reflect new order
        try { renderTasks(); } catch {}
 
        // Clean up potential drag state
        window._potentialDragElement = null;
        window._potentialDragTaskId = null;
      }
      
      function updateTaskSortOrder(taskId, newIndex) {
        const activeTasks = getActive();
        const taskToMove = activeTasks.find(t => t.id === taskId);
        if (!taskToMove) return;
        
        // Create new sort orders based on the new position
        const newSortOrders = [];
        activeTasks.forEach((task, index) => {
          if (task.id === taskId) return; // Skip the moved task
          
          if (index === newIndex) {
            newSortOrders.push({ id: taskId, sortOrder: index * 1000 });
            newSortOrders.push({ id: task.id, sortOrder: (index + 0.5) * 1000 });
          } else if (index > newIndex) {
            newSortOrders.push({ id: task.id, sortOrder: (index + 1) * 1000 });
          } else {
            newSortOrders.push({ id: task.id, sortOrder: index * 1000 });
          }
        });
        
        // If dropping at the end
        if (newIndex >= activeTasks.length - 1) {
          newSortOrders.push({ id: taskId, sortOrder: activeTasks.length * 1000 });
        }
        
        // Update tasks state with new sort orders
        setTasks(prev => {
          return prev.map(task => {
            const newOrder = newSortOrders.find(o => o.id === task.id);
            if (newOrder) {
              return { ...task, sortOrder: newOrder.sortOrder };
            }
            return task;
          });
        });
        
        if (window.__DRAG_DEBUG) console.log('DevLog: Updated sort orders:', newSortOrders);
      }

      // Enhanced swipe gesture detection with smooth physics
      function addSwipeGesture(container, content) {
        let suppressSwipe = false; // Prevent swipe while dragging
        let startX = 0;
        let currentX = 0;
        let isDragging = false;
        let startTime = 0;
        let lastMoveTime = 0;
        let velocity = 0;
        
        // Get responsive swipe distances based on screen size
        const getSwipeDistances = () => {
          const isMobile = window.innerWidth <= 480;
          const slideDistance = isMobile ? 100 : 120; // Updated for both buttons
          return {
            maxSwipe: -slideDistance, // Cap at slide distance to reveal both buttons
            threshold: -slideDistance * 0.4, // 40% of slide distance to trigger
            resistance: 0.1 // Minimal resistance for natural feel
          };
        };
        
        function handleStart(e) {
          // Prevent conflicts with other interactions
          if (e.target.closest('.edit-btn') || e.target.closest('.delete-btn') || e.target.closest('input') || e.target.closest('button')) {
            return;
          }
          
          // Disable swipe for completed tasks
          if (content.classList.contains('task--done')) {
            return;
          }
          
          // Don't start swipe if we're in active drag mode or swipe suppressed
          if (isDragMode || suppressSwipe) {
            return;
          }
          
          // For draggable elements, give priority to drag over swipe
          if (container.draggable) {
            // Set a delay to see if drag starts first
            setTimeout(() => {
              // Only start swipe if no drag operation started and gesture hasn't been decided
              if (!isDragMode && !container.classList.contains('dragging') && !isGestureDecided && !suppressSwipe) {
                startSwipeGesture(e);
              } else {
                console.log('ðŸ”„ DevLog: Swipe canceled - drag operation in progress or gesture decided');
              }
            }, 50); // Even shorter delay for better gesture detection
            return;
          }
          
          startSwipeGesture(e);
        }
        
        function startSwipeGesture(e) {
          startX = e.touches ? e.touches[0].clientX : e.clientX;
          currentX = startX;
          isDragging = true;
          startTime = Date.now();
          lastMoveTime = startTime;
          velocity = 0;
          
          // Remove transitions for immediate responsiveness
          content.style.transition = 'none';
          content.style.willChange = 'transform';
          
          // Close other open swipes smoothly
          document.querySelectorAll('.task-swipe-container.swiped').forEach(other => {
            if (other !== container) {
              other.classList.remove('swiped');
            }
          });
          
          // Prevent scrolling during swipe
          e.preventDefault();
        }
        
        function handleMove(e) {
          if (!isDragging) return;
          
          e.preventDefault();
          const now = Date.now();
          const prevX = currentX;
          currentX = e.touches ? e.touches[0].clientX : e.clientX;
          const deltaX = currentX - startX;
          const timeDelta = now - lastMoveTime;
          
          // Calculate velocity for momentum (improved smoothing)
          if (timeDelta > 0) {
            const currentVelocity = (currentX - prevX) / timeDelta;
            velocity = velocity * 0.8 + currentVelocity * 0.2; // Smooth velocity
          }
          lastMoveTime = now;
          
          const distances = getSwipeDistances();
          const isCurrentlyOpen = container.classList.contains('swiped');
          let translateX = deltaX;
          
          if (isCurrentlyOpen) {
            // When open, start from the open position
            translateX = distances.maxSwipe + deltaX;
            // Clamp between open position and closed position
            translateX = Math.max(Math.min(translateX, 0), distances.maxSwipe);
          } else {
            // When closed, normal left swipe behavior
            if (deltaX < 0) {
              // Left swipe - cap at max swipe distance
              translateX = Math.max(deltaX, distances.maxSwipe);
            } else {
              // Right swipe when closed - minimal resistance
              translateX = Math.min(deltaX * 0.05, 5);
            }
          }
          
          // Apply transform following finger exactly
          requestAnimationFrame(() => {
            content.style.transform = `translate3d(${translateX}px, 0, 0)`;
          });
        }
        
        function handleEnd(e) {
          if (!isDragging) return;
          isDragging = false;
          
          const deltaX = currentX - startX;
          const deltaTime = Date.now() - startTime;
          const distances = getSwipeDistances();
          const isCurrentlyOpen = container.classList.contains('swiped');
          
          // Calculate final velocity for momentum-based decisions
          const finalVelocity = Math.abs(velocity);
          const velocityThreshold = 0.3;
          
          // Restore smooth transitions with natural easing
          content.style.transition = 'transform 0.25s cubic-bezier(0.2, 0.0, 0.2, 1)';
          content.style.willChange = 'auto';
          
          let shouldBeOpen = false;
          
          if (isCurrentlyOpen) {
            // When currently open, determine if it should stay open or close
            const currentTranslate = distances.maxSwipe + deltaX;
            const closeThreshold = distances.maxSwipe * 0.6; // 60% of the way back to close
            
            // Close if swiped far enough right OR fast right velocity
            const shouldClose = currentTranslate > closeThreshold || 
                               (velocity > velocityThreshold && deltaX > 0);
            
            shouldBeOpen = !shouldClose;
          } else {
            // When currently closed, determine if it should open
            const openThreshold = distances.threshold; // 40% of max distance
            
            // Open if swiped far enough left OR fast left velocity
            shouldBeOpen = deltaX < openThreshold || 
                          (velocity < -velocityThreshold && deltaX < 0);
          }
          
          if (shouldBeOpen) {
            container.classList.add('swiped');
            // Ensure exact positioning
            requestAnimationFrame(() => {
              content.style.transform = `translate3d(${distances.maxSwipe}px, 0, 0)`;
            });
          } else {
            container.classList.remove('swiped');
            // Snap back to origin
            requestAnimationFrame(() => {
              content.style.transform = 'translate3d(0, 0, 0)';
            });
          }
          
          // Clean up inline styles after transition
          setTimeout(() => {
            content.style.transform = '';
            content.style.transition = '';
            content.style.willChange = '';
          }, 250);
        }
        
        // Enhanced event listeners with better passive handling
        content.addEventListener('touchstart', handleStart, { passive: false });
        content.addEventListener('touchmove', handleMove, { passive: false });
        content.addEventListener('touchend', handleEnd, { passive: true });
        content.addEventListener('touchcancel', handleEnd, { passive: true });
        
        // Prevent context menu on long press
        content.addEventListener('contextmenu', (e) => {
          if (isDragging) e.preventDefault();
        });
        
        // Close on click outside or light tap when open
        content.addEventListener('click', (e) => {
          // Only close if it was a light tap (not a drag) and currently open
          if (!isDragging && container.classList.contains('swiped') && Math.abs(currentX - startX) < 5) {
            container.classList.remove('swiped');
            content.style.transition = 'transform 0.25s cubic-bezier(0.2, 0.0, 0.2, 1)';
            content.style.transform = 'translate3d(0, 0, 0)';
            setTimeout(() => {
              content.style.transform = '';
              content.style.transition = '';
            }, 250);
          }
        });
        
        // Mouse events for desktop testing with improved handling
        content.addEventListener('mousedown', handleStart);
        
        // Global mouse events to handle dragging outside element
        const handleMouseMove = (e) => {
          if (isDragging) handleMove(e);
        };
        const handleMouseUp = (e) => {
          if (isDragging) handleEnd(e);
        };
        
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        // Close swipe when clicking elsewhere or scrolling
        const closeSwipe = (e) => {
          if (!container.contains(e.target) && !e.target.closest('.modal')) {
            container.classList.remove('swiped');
          }
        };
        
        document.addEventListener('click', closeSwipe);
        document.addEventListener('scroll', () => {
          container.classList.remove('swiped');
        }, { passive: true });
        
        // Handle window resize for responsive behavior
        const handleResize = () => {
          if (container.classList.contains('swiped')) {
            // Re-trigger swipe state to adjust for new screen size
            container.classList.remove('swiped');
            setTimeout(() => {
              container.classList.add('swiped');
            }, 50);
          }
        };
        
        window.addEventListener('resize', handleResize, { passive: true });

        // Listen for drag lifecycle to suppress swipe
        document.addEventListener('dragstart', (evt) => {
          const card = evt.target?.closest?.('.task-swipe-container');
          if (card && card === container) {
            suppressSwipe = true;
            container.classList.remove('swiped');
            content.style.transform = '';
          }
        }, true);

        document.addEventListener('dragend', (evt) => {
          const card = evt.target?.closest?.('.task-swipe-container');
          if (card && card === container) {
            suppressSwipe = false;
          }
        }, true);
      }

      // Edit modal functionality
      let currentEditingTask = null;
      
      function openEditModal(task) {
        currentEditingTask = task;
        const editBackdrop = document.getElementById('edit-modal-backdrop');
        const editTitle = document.getElementById('edit-task-title');
        const editDuration = document.getElementById('edit-task-duration');
        const editTag = document.getElementById('edit-task-tag');
        
        // Populate form with current task data
        editTitle.value = task.title || '';
        editDuration.value = task.minutes || '';
        editTag.value = task.tag || '';
        
        editBackdrop.removeAttribute('hidden');
        editTitle.focus();
        
        // Close any open swipe actions
        document.querySelectorAll('.task-swipe-container.swiped').forEach(container => {
          container.classList.remove('swiped');
        });
      }
      
      function closeEditModal() {
        const editBackdrop = document.getElementById('edit-modal-backdrop');
        editBackdrop.setAttribute('hidden', '');
        currentEditingTask = null;
      }
      
      function saveTaskEdit() {
        if (!currentEditingTask) return;
        
        const editTitle = document.getElementById('edit-task-title');
        const editDuration = document.getElementById('edit-task-duration');
        const editTag = document.getElementById('edit-task-tag');
        
        // Validate title
        if (!editTitle.value.trim()) {
          editTitle.classList.add('shake');
          editTitle.focus();
          setTimeout(() => editTitle.classList.remove('shake'), 500);
          return;
        }
        
        // Update task
        setTasks(prev => {
          return prev.map(task => {
            if (task.id === currentEditingTask.id) {
              const updatedTask = {
                ...task,
                title: editTitle.value.trim(),
                tag: editTag.value.trim() || undefined,
              };
              
              // Handle duration changes
              const newMinutes = editDuration.value ? parseInt(editDuration.value) : undefined;
              if (newMinutes !== task.minutes) {
                updatedTask.minutes = newMinutes;
                // Reset timer if duration changed
                if (task.timer) {
                  updatedTask.timer = {
                    totalSec: newMinutes ? newMinutes * 60 : 0,
                    remainingSec: newMinutes ? newMinutes * 60 : 0,
                    status: 'idle',
                    updatedAt: Date.now()
                  };
                } else if (newMinutes) {
                  updatedTask.timer = {
                    totalSec: newMinutes * 60,
                    remainingSec: newMinutes * 60,
                    status: 'idle',
                    updatedAt: Date.now()
                  };
                }
              }
              
              console.log('DevLog: Task updated:', updatedTask.title);
              return updatedTask;
            }
            return task;
          });
        });
        
        closeEditModal();
        createToast('Task updated');
      }
      
      // Show delete confirmation modal
      let taskToDelete = null;
      
      function showDeleteModal(taskId) {
        taskToDelete = taskId;
        const deleteBackdrop = document.getElementById('delete-modal-backdrop');
        deleteBackdrop.removeAttribute('hidden');
        
        // Close any open swipe actions and reset transforms so user can see the task clearly
        document.querySelectorAll('.task-swipe-container.swiped').forEach(container => {
          container.classList.remove('swiped');
          const taskContent = container.querySelector('.task-content');
          if (taskContent) {
            taskContent.style.transform = '';
          }
        });
        
        // Focus the cancel button for accessibility
        const cancelBtn = document.getElementById('delete-modal-cancel');
        setTimeout(() => cancelBtn.focus(), 100);
      }
      
      function closeDeleteModal() {
        const deleteBackdrop = document.getElementById('delete-modal-backdrop');
        deleteBackdrop.setAttribute('hidden', '');
        taskToDelete = null;
      }
      
      function confirmDeleteTask() {
        if (!taskToDelete) return;
        
        // SAVE taskToDelete before closing modal (closeDeleteModal sets it to null)
        const taskIdToDelete = taskToDelete;
        const taskElement = document.querySelector(`[data-task-id="${taskIdToDelete}"]`);
        
        // Close the modal first
        closeDeleteModal();
        
        if (taskElement) {
          console.log('DevLog: Preparing delete animation for task:', taskIdToDelete);
          
          // Close any open swipe first
          taskElement.classList.remove('swiped');
          const taskContent = taskElement.querySelector('.task-content');
          if (taskContent) {
            taskContent.style.transform = '';
          }
          
          // Mark as animating to prevent interference from renderTasks
          taskElement.dataset.animatingDelete = 'true';
          
          // Wait for modal to close, then start animation
          setTimeout(() => {
            console.log('DevLog: Starting delete animation for task:', taskIdToDelete);
            
            // REMOVE from state when animation starts (not immediately)
            console.log('DevLog: Removing task from state as animation begins');
            setTasks(prev => {
              const newTasks = prev.filter(t => t.id !== taskIdToDelete);
              console.log('DevLog: Tasks after deletion:', newTasks.length, 'remaining');
              return newTasks;
            });
            
            // Wait for renderTasks to complete DOM manipulation, then apply styles
            setTimeout(() => {
              const animatingElement = document.querySelector(`[data-task-id="${taskIdToDelete}"]`);
              if (animatingElement) {
                console.log('DevLog: Applying animation styles after DOM stabilization');
                
                // Add smooth, slower slide-out animation for cooler effect
                animatingElement.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                animatingElement.style.transform = 'translateX(-100%)';
                animatingElement.style.opacity = '0';
                
                // After animation completes, just remove the DOM element and show toast
                setTimeout(() => {
                  console.log('DevLog: Animation complete, cleaning up DOM element');
                  
                  // Remove the animating flag and element
                  animatingElement.remove();
                  createToast('Task deleted');
                }, 800); // Match slower animation duration
              } else {
                console.log('DevLog: Animating element not found after DOM manipulation');
                createToast('Task deleted');
              }
            }, 50); // Small delay for DOM to stabilize after renderTasks
            
          }, 200); // Delay to let modal close and user see the task
          
        } else {
          // Fallback if element not found
          console.log('DevLog: Task element not found, removing from state directly');
          setTasks(prev => prev.filter(t => t.id !== taskIdToDelete));
          createToast('Task deleted');
        }
      }
      
      // Legacy function for backward compatibility
      function deleteTask(taskId) {
        showDeleteModal(taskId);
      }

      // Get task data from DOM card
      function getTaskFromCard(card) {
        const checkbox = card.querySelector('input[data-role="toggle-done"]');
        const titleEl = card.querySelector('.task-title');
        const tagEl = card.querySelector('.muted');
        const durationEl = card.querySelector('span[style*="border-radius:999px"]');
        
        return {
          id: card.dataset.taskId,
          title: titleEl ? titleEl.textContent : '',
          tag: tagEl ? tagEl.textContent : '',
          minutes: durationEl ? parseInt(durationEl.textContent) : undefined,
          completed: checkbox ? checkbox.checked : false,
          createdAt: new Date().toISOString()
        };
      }

      // Modal management
      (function () {
        const backdrop = document.getElementById('modal-backdrop');
        const cancelBtn = document.getElementById('modal-cancel');
        const saveBtn = document.getElementById('modal-save');
        const fab = document.querySelector('.fab');
        const form = document.getElementById('task-form');
        const titleInput = document.getElementById('task-title');
        const durationSelect = document.getElementById('task-duration');
        const tagInput = document.getElementById('task-tag');
        const todayList = document.getElementById('today-list');

        function hideModal() { 
          backdrop.setAttribute('hidden',''); 
          form.reset();
          titleInput.classList.remove('shake');
        }
        
        function showModal() { 
          backdrop.removeAttribute('hidden'); 
          titleInput.focus();
        }

        // Ensure hidden on load
        hideModal();

        // FAB opens modal
        fab?.addEventListener('click', showModal);

        // Close on Cancel, clicking the dim area, or Esc
        cancelBtn?.addEventListener('click', hideModal);
        backdrop?.addEventListener('click', (e) => {
          if (e.target === backdrop) hideModal();
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') hideModal();
        });

        // Save task
        saveBtn?.addEventListener('click', () => {
          const title = titleInput.value.trim();
          const duration = durationSelect.value;
          const tag = tagInput.value.trim();

          if (!title) {
            titleInput.classList.add('shake');
            titleInput.focus();
            setTimeout(() => titleInput.classList.remove('shake'), 300);
            return;
          }

          // Create task object
          const task = {
            id: generateId(),
            title: title,
            tag: tag || undefined,
            minutes: duration ? parseInt(duration) : undefined,
            completed: false,
            createdAt: new Date().toISOString()
          };

          // Add task using the state management system
          addTask(task);

          // Close modal and show toast
          hideModal();
          createToast('Task added');
        });

        // Expose for future use (optional)
        window.__modal = { show: showModal, hide: hideModal };
      })();

      // Task state management and persistence
      (function () {
        const todayList = document.getElementById('today-list');
        const completedList = document.getElementById('completed-list');
        const completedCount = document.getElementById('completed-count');
        const clearBtn = document.getElementById('clear-completed');
        const announcements = document.getElementById('task-announcements');

        // State management (like React useState)
        let tasks = [];
        let timerInterval = null;

        function setTasks(updater) {
          // Handle both direct values and updater functions (like React setState)
          const prev = tasks;
          const next = typeof updater === 'function' ? updater(prev) : updater;
          
          // Debug logging for resurrection investigation
          console.log('ðŸ” setTasks called');
          console.log('ðŸ” Previous tasks:', prev.length, prev.map(t => `${t.id}:${t.title}`));
          console.log('ðŸ” Next tasks:', next.length, next.map(t => `${t.id}:${t.title}`));
          console.log('ðŸ” Call stack:', new Error().stack);
          
          tasks = next;
          
          // Auto-save and re-render on state change
          saveTasks(next);  // Immediate save for user actions
          if (!isRenderSuppressedForDrag) {
            renderTasks();
          }
        }

        // Derived state (like useMemo)
        function getActive() {
          return tasks.filter(t => !t.completed).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
        }

        function getDone() {
          return tasks.filter(t => t.completed);
        }

        function announce(text) {
          announcements.textContent = text;
        }

        function updateCompletedCount() {
          const doneCount = getDone().length;
          completedCount.textContent = doneCount;
          
          // Show/hide Clear button like React: {done.length > 0 && <button onClick={clearCompleted}>Clear</button>}
          const clearBtn = document.getElementById('clear-completed');
          if (clearBtn) {
            clearBtn.style.display = doneCount > 0 ? 'block' : 'none';
          }
        }

        // Single toggle function (matches your React pattern exactly)
        function toggleComplete(id) {
          setTasks(prev => {
            const next = prev.map(t => {
              if (t.id === id) {
                const newCompleted = !t.completed;
                let newTask = { ...t, completed: newCompleted };
                
                // If unchecking a completed task, reset its timer
                if (!newCompleted && t.timer) {
                  newTask.timer = {
                    ...t.timer,
                    remainingSec: t.timer.totalSec,
                    status: 'idle',
                    updatedAt: Date.now()
                  };
                  console.log('DevLog: Reset timer for unchecked task:', t.title);
                }
                
                return newTask;
              }
              return t;
            });
            
            // Announce change
            const task = next.find(t => t.id === id);
            if (task) {
              console.log('DevLog: Task completion toggled:', task.title, 'â†’', task.completed);
              console.log('DevLog: State after toggle - active:', next.filter(t => !t.completed).length, 'done:', next.filter(t => t.completed).length);
              announce(task.completed ? 'Task completed' : 'Task active');
            }
            
            return next;
          });
        }

        // Clear completed -> remove completed tasks from storage
        function clearCompleted() {
          setTasks(prev => {
            const before = { active: prev.filter(t => !t.completed).length, done: prev.filter(t => t.completed).length };
            const next = prev.filter(t => !t.completed);
            const after = { active: next.filter(t => !t.completed).length, done: next.filter(t => t.completed).length };
            
            console.log('DevLog:', { step: 'clear-completed', before, after });
            return next;
          });
        }

        function addTask(taskData) {
          // Add timer to new tasks if they have minutes
          if (taskData.minutes && !taskData.timer) {
            taskData.timer = {
              totalSec: taskData.minutes * 60,
              remainingSec: taskData.minutes * 60,
              status: 'idle',
              updatedAt: Date.now()
            };
          }
          
          // Add sortOrder - new tasks go to the top
          if (taskData.sortOrder === undefined) {
            taskData.sortOrder = Date.now();
          }
          
          setTasks(prev => [taskData, ...prev]);
        }

        // Timer management
        function startTimer(taskId) {
          setTasks(prev => {
            const next = prev.map(t => {
              if (t.id === taskId) {
                // Start this timer
                return {
                  ...t,
                  timer: t.timer ? {
                    ...t.timer,
                    status: 'running',
                    updatedAt: Date.now()
                  } : null
                };
              } else if (t.timer && t.timer.status === 'running') {
                // Pause any other running timer
                return {
                  ...t,
                  timer: {
                    ...t.timer,
                    status: 'paused',
                    updatedAt: Date.now()
                  }
                };
              }
              return t;
            });
            return next;
          });
          
          // Start the global timer interval
          if (!timerInterval) {
            timerInterval = setInterval(updateRunningTimers, 1000);
          }
        }

        function pauseTimer(taskId) {
          setTasks(prev => {
            const next = prev.map(t => 
              t.id === taskId && t.timer ? {
                ...t,
                timer: {
                  ...t.timer,
                  status: 'paused',
                  updatedAt: Date.now()
                }
              } : t
            );
            return next;
          });
        }

        function resetTimer(taskId) {
          setTasks(prev => {
            const next = prev.map(t => 
              t.id === taskId && t.timer ? {
                ...t,
                timer: {
                  ...t.timer,
                  remainingSec: t.timer.totalSec,
                  status: 'idle',
                  updatedAt: Date.now()
                }
              } : t
            );
            return next;
          });
        }

        function updateRunningTimers() {
          // Use current tasks directly instead of setTasks callback to avoid stale closures
          const currentTasks = tasks; // Get current state directly
          let hasRunningTimer = false;
          let hasChanges = false;
          
          const updatedTasks = currentTasks.map(task => {
            if (task.timer && task.timer.status === 'running') {
              hasRunningTimer = true;
              const ticked = tickTimer(task);
              
              // Check if timer actually changed to avoid unnecessary updates
              if (ticked.timer.remainingSec !== task.timer.remainingSec) {
                hasChanges = true;
              }
              
              // Auto-complete if timer reaches 0
              if (ticked.timer.remainingSec === 0 && !task.completed) {
                console.log('DevLog: Timer completed for task:', task.title);
                hasChanges = true;
                
                // Add completion pulse animation
                setTimeout(() => {
                  const card = document.querySelector(`[data-task-id="${task.id}"]`);
                  if (card) {
                    card.classList.add('timer-complete-pulse');
                    setTimeout(() => card.classList.remove('timer-complete-pulse'), 300);
                  }
                }, 100);
                
                return {
                  ...ticked,
                  completed: true,
                  timer: {
                    ...ticked.timer,
                    status: 'idle'
                  }
                };
              }
              return ticked;
            }
            return task;
          });
          
          // Only update state if there were actual changes
          if (hasChanges) {
            console.log('ðŸ”„ Timer update: updating', updatedTasks.length, 'tasks');
            // Update state directly instead of using callback to avoid stale closure issues
            tasks = updatedTasks;
            debouncedSave(updatedTasks);
            if (!isRenderSuppressedForDrag) {
              renderTasks();
            }
          }
          
          // Clean up interval if no running timers
          if (!hasRunningTimer && timerInterval) {
            console.log('ðŸ”„ Timer update: stopping timer interval');
            clearInterval(timerInterval);
            timerInterval = null;
          }
        }

        function renderTasks() {
          // Derive lists from state (like useMemo)
          const active = getActive();
          const done = getDone();

          if (window.__DRAG_DEBUG) console.log('DevLog: Rendering tasks - active:', active.length, 'done:', done.length);
          if (window.__DRAG_DEBUG) console.log('DevLog: Active task IDs:', active.map(t => t.id));
          if (window.__DRAG_DEBUG) console.log('DevLog: Done task IDs:', done.map(t => t.id));
          
          // Debug existing elements
          const allExisting = [...todayList.children, ...completedList.children];
          const animatingCount = allExisting.filter(el => el.dataset.animatingDelete === 'true').length;
          if (window.__DRAG_DEBUG) console.log('DevLog: Found', animatingCount, 'animating delete elements');

          // Get existing cards to avoid destroying checkbox state
          // BUT exclude animating delete elements to prevent resurrection
          const existingCards = new Map();
          Array.from(todayList.children).forEach(card => {
            if (card.dataset.taskId && card.dataset.animatingDelete !== 'true') {
              existingCards.set(card.dataset.taskId, card);
            }
          });
          Array.from(completedList.children).forEach(card => {
            if (card.dataset.taskId && card.dataset.animatingDelete !== 'true') {
              existingCards.set(card.dataset.taskId, card);
            }
          });

          // Clear containers completely, but preserve animating delete elements
          console.log('DevLog: Before clearing - todayList children:', todayList.children.length, 'completedList children:', completedList.children.length);
          
          // Preserve animating delete elements with their current positions
          const animatingElements = [];
          Array.from(todayList.children).forEach((child, index) => {
            if (child.dataset.animatingDelete === 'true') {
              animatingElements.push({ element: child, originalIndex: index });
              console.log('DevLog: Preserving animating element:', child.dataset.taskId, 'at index:', index);
            }
          });
          Array.from(completedList.children).forEach((child, index) => {
            if (child.dataset.animatingDelete === 'true') {
              animatingElements.push({ element: child, originalIndex: index });
              console.log('DevLog: Preserving animating element:', child.dataset.taskId, 'at index:', index);
            }
          });
          
          todayList.innerHTML = '';
          completedList.innerHTML = '';
          
          console.log('DevLog: After clearing - todayList children:', todayList.children.length, 'completedList children:', completedList.children.length);

          // Render active tasks first
          active.forEach(task => {
            let card = existingCards.get(task.id);
            if (card) {
              // Update existing card state
              updateCardFromTask(card, task);
            } else {
              // Create new card
              card = createTaskCard(task);
            }
            todayList.appendChild(card);
          });
          
          // Insert animating elements at their original positions
          animatingElements.forEach(animatingInfo => {
            const { element, originalIndex } = animatingInfo;
            const taskId = element.dataset.taskId;
            
            // Insert at the original index, or at the end if index is too high
            const currentChildren = Array.from(todayList.children);
            const insertIndex = Math.min(originalIndex, currentChildren.length);
            
            if (insertIndex >= currentChildren.length) {
              // Append at end
              todayList.appendChild(element);
              console.log('DevLog: Appended animating element', taskId, 'at end (original index', originalIndex, 'was too high)');
            } else {
              // Insert before the element at insertIndex
              todayList.insertBefore(element, currentChildren[insertIndex]);
              console.log('DevLog: Inserted animating element', taskId, 'at index', insertIndex, '(original index', originalIndex, ')');
            }
          });

          // Render completed tasks - reuse existing cards where possible  
          done.forEach(task => {
            let card = existingCards.get(task.id);
            if (card) {
              // Update existing card state
              updateCardFromTask(card, task);
            } else {
              // Create new card
              card = createTaskCard(task);
            }
            completedList.appendChild(card);
          });

          // Update completed section header (like <span>Completed ({done.length})</span>)
          updateCompletedCount();
          updateDebugFooter(active.length, done.length);
        }

        function updateCardFromTask(swipeContainer, task) {
          // Get the task content div
          const taskContent = swipeContainer.querySelector('.task-content');
          if (!taskContent) return;
          
          // Update checkbox state without destroying it
          const checkbox = taskContent.querySelector('input[data-role="toggle-done"]');
          if (checkbox) {
            checkbox.checked = task.completed;
            checkbox.setAttribute('aria-label', `Mark ${task.title} ${task.completed ? 'incomplete' : 'complete'}`);
          }

          // Update visual state
          if (task.completed) {
            taskContent.classList.add('task--done');
            // Clear any swipe state for completed tasks
            swipeContainer.classList.remove('swiped');
            taskContent.style.transform = '';
          } else {
            taskContent.classList.remove('task--done');
          }

          // Update ticking animation
          if (task.timer && task.timer.status === 'running') {
            taskContent.classList.add('task-ticking');
          } else {
            taskContent.classList.remove('task-ticking');
          }

          // Update task title and tag
          const titleElement = taskContent.querySelector('.task-title');
          if (titleElement) {
            titleElement.textContent = task.title;
          }
          
          const tagElement = taskContent.querySelector('.muted');
          if (task.tag) {
            if (tagElement) {
              tagElement.textContent = task.tag;
            } else {
              // Add tag element if it doesn't exist
              const titleParent = titleElement?.parentElement;
              if (titleParent) {
                const newTagElement = document.createElement('div');
                newTagElement.className = 'muted';
                newTagElement.style.fontSize = '13px';
                newTagElement.textContent = task.tag;
                titleParent.appendChild(newTagElement);
              }
            }
          } else if (tagElement) {
            // Remove tag element if task has no tag
            tagElement.remove();
          }

          // Update timer display and button text
          const timerSpan = taskContent.querySelector('span[style*="border-radius:999px"]');
          const startBtn = taskContent.querySelector('[data-role="timer-control"]');
          const resetBtn = taskContent.querySelector('[data-role="reset-timer"]');

          if (task.timer && timerSpan) {
            timerSpan.textContent = formatTime(task.timer.remainingSec);
          }

          if (startBtn && task.timer) {
            if (task.timer.status === 'running') {
              startBtn.textContent = 'Pause';
            } else if (task.timer.status === 'paused') {
              startBtn.textContent = 'Resume';
            } else {
              startBtn.textContent = 'Start';
            }
          }
          
          // Update edit and delete buttons to have current task reference
          const editBtn = swipeContainer.querySelector('.edit-btn');
          const deleteBtn = swipeContainer.querySelector('.delete-btn');
          
          if (editBtn) {
            // Remove old listener and add new one with updated task
            const newEditBtn = editBtn.cloneNode(true);
            editBtn.parentNode.replaceChild(newEditBtn, editBtn);
            newEditBtn.addEventListener('click', function() {
              openEditModal(task);
            });
          }
          
          if (deleteBtn) {
            // Remove old listener and add new one with updated task
            const newDeleteBtn = deleteBtn.cloneNode(true);
            deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
            newDeleteBtn.addEventListener('click', function() {
              deleteTask(task.id);
            });
          }
        }

        function updateDebugFooter(activeCount, doneCount) {
          const debugFooter = document.getElementById('debug-footer');
          if (debugFooter) {
            debugFooter.textContent = `build: STEP-1.62-drag-visual-sync â€” active:${activeCount} done:${doneCount}`;
          }
        }

        // Controlled checkbox event delegation
        function handleCheckboxChange(e) {
          console.log('ðŸ”„ Checkbox change event fired');
          const checkbox = e.target;
          console.log('Checkbox details:', { type: checkbox.type, role: checkbox.dataset.role, checked: checkbox.checked });
          
          if (checkbox.type === 'checkbox' && checkbox.dataset.role === 'toggle-done') {
            const card = checkbox.closest('div[style*="display:flex"]');
            const taskId = card?.dataset.taskId;
            console.log('Found card with taskId:', taskId);
            
            if (taskId) {
              console.log('Calling toggleComplete for task:', taskId);
              // Don't prevent default - let checkbox update naturally, then sync state
              toggleComplete(taskId);
            } else {
              console.log('âŒ No taskId found on card');
            }
          }
        }

        // Timer control event handler
        function handleTimerControl(e) {
          const button = e.target;
          if (button.dataset.role === 'timer-control') {
            const card = button.closest('div[style*="display:flex"]');
            const taskId = card?.dataset.taskId;
            const task = tasks.find(t => t.id === taskId);
            
            if (taskId && task && task.timer) {
              if (task.timer.status === 'idle') {
                console.log('DevLog: Starting timer for:', task.title);
                startTimer(taskId);
              } else if (task.timer.status === 'running') {
                console.log('DevLog: Pausing timer for:', task.title);
                pauseTimer(taskId);
              } else if (task.timer.status === 'paused') {
                console.log('DevLog: Resuming timer for:', task.title);
                startTimer(taskId);
              }
            }
          } else if (button.dataset.role === 'reset-timer') {
            const card = button.closest('div[style*="display:flex"]');
            const taskId = card?.dataset.taskId;
            const task = tasks.find(t => t.id === taskId);
            
            if (taskId && task) {
              console.log('DevLog: Resetting timer for:', task.title);
              resetTimer(taskId);
            }
          }
        }

        // Event listeners with debug
        console.log('ðŸ”§ Setting up event listeners...');
        console.log('todayList found:', !!todayList);
        console.log('completedList found:', !!completedList);
        
        // Add a simple click listener to test if ANY events work
        todayList?.addEventListener('click', function(e) {
          console.log('ðŸ–±ï¸ Click detected on todayList:', e.target.tagName, e.target.type);
        });
        
        todayList?.addEventListener('change', handleCheckboxChange);
        completedList?.addEventListener('change', handleCheckboxChange);
        todayList?.addEventListener('click', handleTimerControl);
        completedList?.addEventListener('click', handleTimerControl);

        clearBtn?.addEventListener('click', clearCompleted);

        // Edit modal event listeners
        const editBackdrop = document.getElementById('edit-modal-backdrop');
        const editCancelBtn = document.getElementById('edit-modal-cancel');
        const editSaveBtn = document.getElementById('edit-modal-save');
        
        editCancelBtn?.addEventListener('click', closeEditModal);
        editSaveBtn?.addEventListener('click', saveTaskEdit);
        
        // Close edit modal on backdrop click
        editBackdrop?.addEventListener('click', function(e) {
          if (e.target === editBackdrop) closeEditModal();
        });
        
        // Close edit modal on Escape key
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape' && !editBackdrop?.hasAttribute('hidden')) {
            closeEditModal();
          }
        });

        // Delete modal event listeners
        const deleteBackdrop = document.getElementById('delete-modal-backdrop');
        const deleteCancelBtn = document.getElementById('delete-modal-cancel');
        const deleteConfirmBtn = document.getElementById('delete-modal-confirm');
        
        deleteCancelBtn?.addEventListener('click', closeDeleteModal);
        deleteConfirmBtn?.addEventListener('click', confirmDeleteTask);
        
        // Close delete modal on backdrop click
        deleteBackdrop?.addEventListener('click', function(e) {
          if (e.target === deleteBackdrop) closeDeleteModal();
        });
        
        // Close delete modal on Escape key
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape' && !deleteBackdrop?.hasAttribute('hidden')) {
            closeDeleteModal();
          }
        });

        // Export / Import (JSON)
        const exportBtn = document.getElementById('export-json-btn');
        const importBtn = document.getElementById('import-json-btn');
        const importInput = document.getElementById('import-file');

        function exportTasksToJSON() {
          try {
            const payload = {
              version: 'v1',
              exportedAt: new Date().toISOString(),
              tasks: tasks
            };
            const json = JSON.stringify(payload, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `planner-tasks-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }, 0);
            createToast(`Exported ${tasks.length} tasks`);
          } catch (e) {
            console.warn('Export failed:', e);
            createToast('Export failed');
          }
        }

        function normalizeImportedTasks(input) {
          const rawArray = Array.isArray(input) ? input :
                           (input && Array.isArray(input.tasks) ? input.tasks :
                           (input && Array.isArray(input.data) ? input.data : null));
          if (!rawArray) return null;

          const normalized = rawArray.map((t, index) => {
            const minutesNum = typeof t.minutes === 'string' ? parseInt(t.minutes, 10) :
                               typeof t.minutes === 'number' ? t.minutes : undefined;
            const hasMinutes = typeof minutesNum === 'number' && !Number.isNaN(minutesNum);

            const normalizedTimer = t.timer ? {
              totalSec: typeof t.timer.totalSec === 'number' ? t.timer.totalSec : (hasMinutes ? minutesNum * 60 : 0),
              remainingSec: typeof t.timer.remainingSec === 'number' ? t.timer.remainingSec : (hasMinutes ? minutesNum * 60 : 0),
              status: (t.timer.status === 'running' || t.timer.status === 'paused') ? t.timer.status : 'idle',
              updatedAt: typeof t.timer.updatedAt === 'number' ? t.timer.updatedAt : Date.now()
            } : (hasMinutes ? {
              totalSec: minutesNum * 60,
              remainingSec: minutesNum * 60,
              status: 'idle',
              updatedAt: Date.now()
            } : null);

            return {
              id: String(t.id || generateId()),
              title: String(t.title || 'Untitled'),
              note: t.note || '',
              minutes: hasMinutes ? minutesNum : undefined,
              tag: t.tag || '',
              completed: !!(t.completed || t.checked || t.done || t.isDone || false),
              sortOrder: t.sortOrder !== undefined ? t.sortOrder : index * 1000,
              timer: normalizedTimer
            };
          });

          return normalized;
        }

        function handleImportFile(files) {
          if (!files || files.length === 0) return;
          const file = files[0];

          if (!confirm('Importing will replace all existing tasks. Continue?')) {
            return;
          }

          const reader = new FileReader();
          reader.onload = function(evt) {
            try {
              const text = evt.target?.result || '';
              const parsed = JSON.parse(text);
              const normalized = normalizeImportedTasks(parsed);
              if (!normalized) {
                createToast('Invalid JSON format');
                return;
              }
              setTasks(normalized);
              createToast(`Imported ${normalized.length} tasks`);
            } catch (e) {
              console.warn('Import failed:', e);
              createToast('Import failed');
            } finally {
              if (importInput) importInput.value = '';
            }
          };
          reader.onerror = function() {
            createToast('Failed to read file');
            if (importInput) importInput.value = '';
          };
          reader.readAsText(file);
        }

        exportBtn?.addEventListener('click', exportTasksToJSON);
        importBtn?.addEventListener('click', () => importInput?.click());
        importInput?.addEventListener('change', (e) => handleImportFile(e.target.files));

        // Expose for debugging
        window.exportTasksToJSON = exportTasksToJSON;

        // Load tasks from storage on init (like useState initialization)
        function loadTasksFromStorage() {
          // Initialize state with loadTasks() (like useState(loadTasks()))
          tasks = loadTasks();
          
          // Resume any running timers
          const hasRunningTimer = tasks.some(t => t.timer && t.timer.status === 'running');
          if (hasRunningTimer && !timerInterval) {
            console.log('DevLog: Resuming timers on page load');
            timerInterval = setInterval(updateRunningTimers, 1000);
          }
          
          renderTasks();
        }

        // Test helper for regression verification
        window.testCheckboxFlow = function() {
          console.log('ðŸ§ª Testing checkbox completion flow...');
          const activeCount = getActive().length;
          const doneCount = getDone().length;
          console.log('Before:', { active: activeCount, done: doneCount });
          
          // Find first active task
          const firstActive = getActive()[0];
          if (firstActive) {
            console.log('Toggling task:', firstActive.title);
            toggleComplete(firstActive.id);
            
            setTimeout(() => {
              const newActiveCount = getActive().length;
              const newDoneCount = getDone().length;
              console.log('After:', { active: newActiveCount, done: newDoneCount });
              
              const success = newActiveCount === activeCount - 1 && newDoneCount === doneCount + 1;
              console.log(success ? 'âœ… Test PASSED' : 'âŒ Test FAILED');
            }, 100);
          } else {
            console.log('No active tasks to test');
          }
        };

        // Quick test for clear functionality
        window.testClearCompleted = function() {
          console.log('ðŸ§ª Testing Clear Completed...');
          const before = { active: getActive().length, done: getDone().length };
          console.log('Before clear:', before);
          
          if (before.done === 0) {
            console.log('No completed tasks to clear. Add and complete a task first.');
            return;
          }
          
          clearCompleted();
          
          setTimeout(() => {
            const after = { active: getActive().length, done: getDone().length };
            console.log('After clear:', after);
            
            const success = after.done === 0 && after.active === before.active;
            console.log(success ? 'âœ… Clear test PASSED' : 'âŒ Clear test FAILED');
          }, 100);
        };

        // Test enhanced swipe-to-edit functionality
        window.testSwipeEdit = function() {
          console.log('ðŸ§ª Testing enhanced swipe-to-edit...');
          const firstTask = getActive()[0];
          if (firstTask) {
            console.log('Opening edit modal for:', firstTask.title);
            openEditModal(firstTask);
          } else {
            console.log('No active tasks to edit. Add a task first.');
          }
        };

        // Test opaque background hiding
        window.testOpaqueHiding = function() {
          console.log('ðŸ§ª Testing opaque background hiding...');
          const containers = document.querySelectorAll('.task-swipe-container');
          if (containers.length > 0) {
            const firstContainer = containers[0];
            const taskContent = firstContainer.querySelector('.task-content');
            const taskActions = firstContainer.querySelector('.task-actions');
            
            if (taskActions && taskContent) {
              const contentStyle = getComputedStyle(taskContent);
              const actionsStyle = getComputedStyle(taskActions);
              
              console.log('=== BACKGROUND OPACITY TEST ===');
              console.log('Task content background:', contentStyle.backgroundColor);
              console.log('Task actions background:', actionsStyle.backgroundColor);
              
              // Check if background is opaque (alpha = 1)
              const bgColor = contentStyle.backgroundColor;
              const isOpaque = bgColor.includes('rgba') ? 
                bgColor.match(/rgba\([^,]+,[^,]+,[^,]+,\s*([^)]+)\)/)?.[1] === '1' :
                !bgColor.includes('rgba'); // rgb() is always opaque
              
              console.log('Task content is opaque:', isOpaque ? 'âœ… YES' : 'âŒ NO');
              
              // Check positioning
              const contentRect = taskContent.getBoundingClientRect();
              const actionsRect = taskActions.getBoundingClientRect();
              
              console.log('=== COVERAGE TEST ===');
              console.log('Content area:', {
                left: contentRect.left,
                right: contentRect.right,
                width: contentRect.width
              });
              console.log('Actions area:', {
                left: actionsRect.left,
                right: actionsRect.right,
                width: actionsRect.width
              });
              
              const fullyCovered = contentRect.left <= actionsRect.left && 
                                 contentRect.right >= actionsRect.right;
              console.log('Actions fully covered:', fullyCovered ? 'âœ… YES' : 'âŒ NO');
              
              console.log('âœ… Opaque hiding test complete');
            }
          }
        };
        
        // Test for visual artifacts and placeholders
        window.testVisualArtifacts = function() {
          console.log('ðŸ§ª Testing for visual artifacts and placeholders...');
          const containers = document.querySelectorAll('.task-swipe-container');
          if (containers.length > 0) {
            const firstContainer = containers[0];
            const taskContent = firstContainer.querySelector('.task-content');
            const taskActions = firstContainer.querySelector('.task-actions');
            const editBtn = firstContainer.querySelector('.edit-btn');
            
            if (taskActions && taskContent && editBtn) {
              console.log('=== ELEMENT VISIBILITY TEST ===');
              
              // Check if elements are actually visible
              const actionsRect = taskActions.getBoundingClientRect();
              const contentRect = taskContent.getBoundingClientRect();
              const btnRect = editBtn.getBoundingClientRect();
              
              console.log('Element visibility:');
              console.log('- Actions visible area:', {
                width: actionsRect.width,
                height: actionsRect.height,
                opacity: getComputedStyle(taskActions).opacity
              });
              console.log('- Button visible area:', {
                width: btnRect.width,
                height: btnRect.height,
                opacity: getComputedStyle(editBtn).opacity,
                display: getComputedStyle(editBtn).display
              });
              
              // Check for any visual artifacts
              const actionsStyle = getComputedStyle(taskActions);
              const btnStyle = getComputedStyle(editBtn);
              
              console.log('=== STYLE ANALYSIS ===');
              console.log('Actions styling:');
              console.log('- Background:', actionsStyle.background);
              console.log('- Border:', actionsStyle.border);
              console.log('- Box-shadow:', actionsStyle.boxShadow);
              console.log('- Border-radius:', actionsStyle.borderRadius);
              
              console.log('Button styling:');
              console.log('- Background:', btnStyle.background);
              console.log('- Border:', btnStyle.border);
              console.log('- Outline:', btnStyle.outline);
              console.log('- Color:', btnStyle.color);
              
              // Check z-index
              const containerZ = parseInt(getComputedStyle(firstContainer).zIndex) || 0;
              const actionsZ = parseInt(getComputedStyle(taskActions).zIndex) || 0;
              const contentZ = parseInt(getComputedStyle(taskContent).zIndex) || 0;
              
              console.log('=== Z-INDEX CHECK ===');
              console.log('- Container:', containerZ);
              console.log('- Actions:', actionsZ, '(should be negative)');
              console.log('- Content:', contentZ, '(should be positive)');
              
              const behindCard = actionsZ < contentZ;
              console.log('Button behind card:', behindCard ? 'âœ… YES' : 'âŒ NO');
              
              console.log('âœ… Visual artifacts test complete');
            }
          }
        };
        
        // Test complete button hiding and drawer effect
        window.testCompleteHiding = function() {
          console.log('ðŸ§ª Testing complete button hiding and drawer effect...');
          const containers = document.querySelectorAll('.task-swipe-container');
          if (containers.length > 0) {
            const firstContainer = containers[0];
            const taskContent = firstContainer.querySelector('.task-content');
            const taskActions = firstContainer.querySelector('.task-actions');
            const editBtn = firstContainer.querySelector('.edit-btn');
            
            if (taskActions && taskContent && editBtn) {
              console.log('=== COMPLETE HIDING TEST ===');
              
              // Check positioning and styling
              const actionsStyle = getComputedStyle(taskActions);
              const contentStyle = getComputedStyle(taskContent);
              const containerStyle = getComputedStyle(firstContainer);
              
              console.log('Positioning analysis:');
              console.log('- Container overflow:', containerStyle.overflow);
              console.log('- Actions right:', actionsStyle.right);
              console.log('- Actions width:', actionsStyle.width);
              console.log('- Actions z-index:', actionsStyle.zIndex);
              console.log('- Actions box-shadow:', actionsStyle.boxShadow);
              console.log('- Actions border:', actionsStyle.border);
              console.log('- Content z-index:', contentStyle.zIndex);
              
              // Check visual overlap
              const contentRect = taskContent.getBoundingClientRect();
              const actionsRect = taskActions.getBoundingClientRect();
              const containerRect = firstContainer.getBoundingClientRect();
              
              console.log('Visual positioning:');
              console.log('- Container bounds:', {
                left: containerRect.left,
                right: containerRect.right,
                width: containerRect.width
              });
              console.log('- Content bounds:', {
                left: contentRect.left,
                right: contentRect.right,
                width: contentRect.width
              });
              console.log('- Actions bounds:', {
                left: actionsRect.left,
                right: actionsRect.right,
                width: actionsRect.width
              });
              
              // Check if any part of actions is visible within container bounds
              const actionsVisibleInContainer = actionsRect.left < containerRect.right && 
                                              actionsRect.right > containerRect.left;
              const actionsCompletelyHidden = actionsRect.left >= containerRect.right;
              
              console.log('Actions visible in container:', actionsVisibleInContainer ? 'âŒ YES (BAD)' : 'âœ… NO (GOOD)');
              console.log('Actions completely outside container:', actionsCompletelyHidden ? 'âœ… YES (GOOD)' : 'âŒ NO (BAD)');
              
              console.log('=== DRAWER REVEAL TEST ===');
              
              // Test drawer effect
              firstContainer.classList.add('swiped');
              
              setTimeout(() => {
                const swipedContentRect = taskContent.getBoundingClientRect();
                const swipedActionsRect = taskActions.getBoundingClientRect();
                const swipedActionsStyle = getComputedStyle(taskActions);
                
                console.log('After swipe styling:');
                console.log('- Actions right:', swipedActionsStyle.right);
                console.log('- Actions width:', swipedActionsStyle.width);
                console.log('- Actions box-shadow:', swipedActionsStyle.boxShadow);
                console.log('- Actions border:', swipedActionsStyle.border);
                
                const buttonNowVisible = swipedActionsRect.right > swipedContentRect.right;
                const drawerEffect = swipedContentRect.left < contentRect.left;
                
                console.log('Drawer slide effect:', drawerEffect ? 'âœ… YES' : 'âŒ NO');
                console.log('Button now visible in gap:', buttonNowVisible ? 'âœ… YES' : 'âŒ NO');
                
                setTimeout(() => {
                  firstContainer.classList.remove('swiped');
                  console.log('âœ… Complete hiding test finished');
                }, 1000);
              }, 300);
            }
          } else {
            console.log('No task containers found');
          }
        };
        
        // Test drag and drop functionality
        window.testDragDrop = function() {
          console.log('ðŸ” Testing drag and drop setup...');
          const draggableElements = document.querySelectorAll('.task-swipe-container[draggable="true"]');
          console.log(`Found ${draggableElements.length} draggable elements`);
          
          draggableElements.forEach((el, i) => {
            console.log(`Element ${i + 1}:`, {
              id: el.dataset.taskId,
              draggable: el.draggable,
              sortOrder: el.dataset.sortOrder,
              classes: el.className
            });
          });
          
          const todayList = document.getElementById('today-list');
          if (todayList) {
            console.log('Event listeners on today-list should be attached via addEventListener');
          }
          
          // Test if draggable attribute is working
          if (draggableElements.length > 0) {
            const firstElement = draggableElements[0];
            console.log('First element draggable attribute:', firstElement.getAttribute('draggable'));
            console.log('First element draggable property:', firstElement.draggable);
          }
          
          console.log('Try clicking and dragging a task card now...');
          console.log('If nothing happens, the issue might be:');
          console.log('1. Swipe gesture interfering with drag');
          console.log('2. Mobile touch events not supporting native drag');
          console.log('3. Event listeners not properly attached');
        };
        
        // Test resurrection bug - automated test
        window.testResurrection = function() {
          console.log('ðŸ§ª === AUTOMATED RESURRECTION TEST ===');
          console.log('ðŸ§ª STEP 1: Creating test task...');
          
          // Step 1: Create a task
          const testTask = {
            id: 'test-resurrection-' + Date.now(),
            title: 'Test Task for Deletion',
            note: '',
            minutes: undefined,
            tag: '',
            completed: false,
            sortOrder: Date.now()
          };
          
          addTask(testTask);
          console.log('ðŸ§ª Task created:', testTask.id, testTask.title);
          
          setTimeout(() => {
            console.log('ðŸ§ª STEP 2: Deleting the task...');
            
            // Step 2: Delete the task
            const taskElement = document.querySelector(`[data-task-id="${testTask.id}"]`);
            if (taskElement) {
              console.log('ðŸ§ª Found task element, simulating deletion...');
              
              // Simulate the deletion process
              taskToDelete = testTask.id;
              confirmDeleteTask();
              
              setTimeout(() => {
                console.log('ðŸ§ª STEP 3: Creating new task after deletion...');
                
                // Step 3: Create a new task
                const newTask = {
                  id: 'new-task-after-deletion-' + Date.now(),
                  title: 'New Task After Deletion',
                  note: '',
                  minutes: undefined,
                  tag: '',
                  completed: false,
                  sortOrder: Date.now() + 1000
                };
                
                addTask(newTask);
                console.log('ðŸ§ª New task created:', newTask.id, newTask.title);
                
                setTimeout(() => {
                  console.log('ðŸ§ª STEP 4: Checking for resurrection...');
                  
                  // Step 4: Check if old task resurrected
                  const allTasks = getActive().concat(getDone());
                  const resurrectedTask = allTasks.find(t => t.id === testTask.id);
                  const newTaskExists = allTasks.find(t => t.id === newTask.id);
                  
                  console.log('ðŸ§ª === RESULTS ===');
                  console.log('ðŸ§ª Total tasks in state:', allTasks.length);
                  console.log('ðŸ§ª Task IDs:', allTasks.map(t => t.id));
                  console.log('ðŸ§ª Task titles:', allTasks.map(t => t.title));
                  console.log('ðŸ§ª Deleted task resurrected?', resurrectedTask ? 'âŒ YES (BUG!)' : 'âœ… NO (GOOD)');
                  console.log('ðŸ§ª New task exists?', newTaskExists ? 'âœ… YES (GOOD)' : 'âŒ NO (BUG!)');
                  
                  if (resurrectedTask) {
                    console.log('ðŸ§ª âŒ RESURRECTION BUG DETECTED!');
                    console.log('ðŸ§ª Resurrected task:', resurrectedTask);
                  } else {
                    console.log('ðŸ§ª âœ… NO RESURRECTION - BUG FIXED!');
                  }
                  
                  // Check DOM as well
                  const domElements = document.querySelectorAll('.task-swipe-container');
                  console.log('ðŸ§ª DOM elements count:', domElements.length);
                  domElements.forEach((el, i) => {
                    console.log(`ðŸ§ª DOM Task ${i+1}:`, el.dataset.taskId, el.querySelector('[style*="font-weight:600"]')?.textContent);
                  });
                  
                }, 1000); // Wait for new task to be added
              }, 2000); // Wait for deletion animation
            } else {
              console.log('ðŸ§ª âŒ Could not find task element to delete');
            }
          }, 500); // Wait for first task to be added
        };

        // Expose functions and state globally
        window.toggleComplete = toggleComplete;
        window.addTask = addTask;
        window.clearCompleted = clearCompleted;
        window.setTasks = setTasks;
        window.getActive = getActive;
        window.getDone = getDone;
        window.openEditModal = openEditModal;
        window.loadTasks = loadTasks;
        window.saveTasks = saveTasks;
        
        // Expose tasks state for debugging
        Object.defineProperty(window, 'tasks', {
          get: () => tasks,
          set: (value) => { tasks = value; }
        });

        // Initialize
        loadTasksFromStorage();
        
        // Initialize drag and drop
        addDragAndDropHandlers();
        
        // Development guardrail
        console.log('ðŸ”§ DevLog: Checkbox completion system initialized');
        console.log('ðŸ“‹ Run testCheckboxFlow() to verify checkbox behavior');
        console.log('ðŸ“Š Debug footer shows live active/done counts');
        console.log('ðŸ”„ Drag and drop reordering enabled');
        console.log('ðŸ” Run testDragDrop() to debug drag and drop');
        console.log('ðŸ§ª Run testResurrection() to test deletion bug automatically!');

        // Programmatic simulation: move active[indexFrom] to indexTo and log
        window.simulateReorder = function(indexFrom, indexTo) {
          const active = getActive();
          if (indexFrom < 0 || indexFrom >= active.length) {
            console.warn('simulateReorder: invalid from', indexFrom);
            return;
          }
          const indexTarget = Math.max(0, Math.min(indexTo, active.length - 1));
          const task = active[indexFrom];
          console.log('ðŸ§ª simulateReorder: moving', task.title, 'from', indexFrom, 'to', indexTarget);
          updateTaskSortOrder(task.id, indexTarget);
          // Verify order
          const after = getActive().map(t => t.title);
          console.log('ðŸ§ª after order:', after);
          // Persisted snapshot
          console.log('ðŸ§ª persisted sortOrders:', window.tasks.map(t => [t.title, t.sortOrder, t.completed]));
        };
      })();
    </script>
  </body>
</html>